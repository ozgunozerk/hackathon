import { ref as l, defineComponent as m, computed as d, watch as g, onMounted as C, onBeforeUnmount as O, h as y } from "vue";
var I = /* @__PURE__ */ ((e) => (e.In = "IN", e.Out = "OUT", e))(I || {}), T = /* @__PURE__ */ ((e) => (e.Up = "UP", e.Down = "DOWN", e.Left = "LEFT", e.Right = "RIGHT", e))(T || {});
const U = (e) => e ? "IN" : "OUT", H = (e, n) => {
  if (e.top < n.top)
    return "UP";
  if (e.left > n.left)
    return "RIGHT";
  if (e.top > n.top)
    return "DOWN";
  if (e.left < n.left)
    return "LEFT";
}, L = (e) => (n) => {
  const r = l();
  return new window.IntersectionObserver(([t]) => {
    var o;
    if (typeof t > "u") {
      console.error("[vue-waypoint]", "observed element is undefined");
      return;
    }
    (o = r.value) != null || (r.value = t.boundingClientRect), n({
      el: t.target,
      going: U(t.isIntersecting),
      direction: H(
        t.boundingClientRect,
        r.value
      )
    }), r.value = t.boundingClientRect;
  }, e);
}, h = m({
  name: "Waypoint",
  props: {
    active: {
      type: Boolean,
      default: () => !0
    },
    options: {
      type: Object,
      default: () => ({})
    },
    tag: {
      type: String,
      default: () => "div"
    },
    disableCssHelpers: {
      type: Boolean,
      default: () => !1
    }
  },
  setup(e, n) {
    const r = typeof window.IntersectionObserver == "function", t = l(!1), o = l(null), v = d(
      () => r && t.value && e.active && o.value !== null
    ), a = l(), b = (u) => a.value = u, c = l(
      L(e.options)(b)
    );
    g(v, () => {
      if (o.value !== null)
        return v.value ? c.value.observe(o.value) : c.value.unobserve(o.value);
    }), g(a, () => {
      typeof a.value > "u" || n.emit("change", a.value);
    }), C(() => t.value = !0), O(() => t.value = !1);
    const w = d(() => {
      var p;
      const { going: u, direction: s } = (p = a.value) != null ? p : {}, i = u && `going-${u.toLowerCase()}`, f = s && `direction-${s.toLowerCase()}`;
      return ["waypoint", i, f];
    });
    return () => {
      var s, i, f;
      const u = e.disableCssHelpers ? { ref: o } : { ref: o, class: w.value };
      return y(
        e.tag,
        u,
        (f = (i = n.slots).default) == null ? void 0 : f.call(i, (s = a.value) != null ? s : {})
      );
    };
  }
});
export {
  T as Direction,
  I as Going,
  h as Waypoint
};
